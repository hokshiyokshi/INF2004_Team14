#include "pico/stdlib.h"
#include "hardware/pwm.h"
#include "stdio.h"


//GPIO pin 8 and 10 = set as power pin
int pin8 = 8;
int pin11 = 11;
//GPIO pin 9 and 12 = set as Ground pin
int groundPin9 = 9;
int groundPin12 = 12;


float elapsedTime= 0.0;

float distance = 0.0;

float speed = 0.0;

void distanceTravelled(){
    //declared as static to retain its value 
    static int turnCount = 0;
    //Radius of the wheel: ~30mm
    //Circumference of the wheel = 2* pi * r = ~ 188.49 ~ 188.5mm
    //188.5 / 20 (Wheel encoder has 20 slots) = 9.425mm per turn 
    distance += 9.425;

    turnCount += 1;

    //DEBUGGING ONLY
    printf("\n Left wheel Turns: %d", turnCount);
    printf("\n Left wheel Distance: %.2f", distance);
    //DEBUGGING ONLY


    // if (turnCount == 20){
    // //print up t 3 d.p
    // printf("\nLeft wheel Distance (Millimeters): %.3f", distance);
    // //print the speed for the last 20 turns
    // printf("\nSpeed: %.3f", 188.5/elapsedTime);

    // //reset the count to 0
    // turnCount = 0;
    // //reset elapsedtime to 0.0   
    // elapsedTime = 0.0;
    // //reset speed to 0
    // speed = 0.0;
    // }//for if loop

} //for distanceTravelledLeft Func


//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!


//Pass the integers to the motors as a variable instead of a value
//Removes guesswork for powering up of motors.
int quarterPower = 3125;
int halfPower = 6250;
int fullPower = 12500; 

//Define pins to enable/disable power output, int corresponds to GPIO
//pins 1 and 2 are used because pin 0 is already used for PWM
int pin1 = 1;
int pin2 = 2;
//Pin 3 unused to preserve wire clarity during assembly
//Pins 4 and 5 are used since pin 6 is already used for PWM
int pin4 = 4;
int pin5 = 5;




    //Function to control the power of the motors.
    //Use together with variables in order to provide appropriate power.
    void motorPower(int power){
        //GPIO pins initialized directly, not as variables.
        //motor 1
        pwm_set_chan_level(pwm_gpio_to_slice_num(0), PWM_CHAN_A, power);
        // Motor 2 (RHS)
        pwm_set_chan_level(pwm_gpio_to_slice_num(6), PWM_CHAN_A, power); 
    }

    //logic 0 = no power (Low), logic 1 = power (high)
    void moveForward(){
        //Forward for LHS gearbox
        gpio_put(pin1, 0);
        gpio_put(pin2, 1);
        //Forward for RHS gearbox
        gpio_put(pin4, 0);
        gpio_put(pin5, 1);
    }//for moveForward Function

    void moveBackward(){
        //Reverse for LHS gearbox
        gpio_put(pin1, 1);
        gpio_put(pin2, 0);
        //Reverse for RHS gearbox
        gpio_put(pin4, 1);
        gpio_put(pin5, 0);
    }//for moveBackward Function

    //Logic: "lock" the left wheel by setting the logic to "0"
    //Rotate the right wheel forward by setting the logic to pin4: 0, pin5: 1
    void turnLeft(){
        //"lock" the left wheel in place
        gpio_put(pin1, 0);
        gpio_put(pin2, 0);
        //Forward for RHS gearbox
        gpio_put(pin4, 0);
        gpio_put(pin5, 1);
    }//for turnLeft Function


    void turnRight(){
        //Rotate the left wheel forward
        gpio_put(pin1, 0);
        gpio_put(pin2, 1);
        //"lock" the right wheel
        gpio_put(pin4, 0);
        gpio_put(pin5, 0);
    }//for turnRight Function

    //i.e, turn on the spot anticlockwise
    void pivotSteerLeft(){
        //Forward for RHS gearbox
        gpio_put(pin4, 0);
        gpio_put(pin5, 1);
        //Reverse for LHS gearbox
        gpio_put(pin1, 1);
        gpio_put(pin2, 0);
    }//for pivotSteerLeft function


    //i.e, turn on the spot clockwise
    void pivotSteerRight(){
        printf("test");
        //Rotate the left wheel forward
        gpio_put(pin1, 0);
        gpio_put(pin2, 1);
        //Reverse for RHS gearbox
        gpio_put(pin4, 1);
        gpio_put(pin5, 0);
    
    }//for pivotSteerRight function


//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!

//FOR DISTANCE
//based on running the motor at 100% (full power), turnCount has recorded a count of
//40(377.00mm) or 41(386.42mm) turns in 1 second (Based on the assumption that the 
//radius is 30mm and circumference = 188.50mm) That is the distance for 1 second. 
//Correspondingly, if the motor is halved in power, it means it will turn 20(188.50mm)
// or 21(~197.93mm) times, and so on. 1 slot = 9.425mm

//FOR TIME
//time in this case can be the "sleep" duration, e.g, sleep_ms(2000) = 2s. To get the speed,

//SOLVING FOR DISTANCE
//Speed = distance / time. in this case, 
//distance = [(386.42mm / 100) * Motor power](Dist in 1 second) * time/1000 (in seconds) 
//time = time / 1000 

//Function for PWM
void speedByPWM(int power, int duration){
    //GPIO pins initialized directly, not as variables.
    //motor 1
    pwm_set_chan_level(pwm_gpio_to_slice_num(0), PWM_CHAN_A, power);
    // Motor 2 (RHS)
    pwm_set_chan_level(pwm_gpio_to_slice_num(6), PWM_CHAN_A, power); 


    //Forward for LHS gearbox
    gpio_put(pin1, 0);
    gpio_put(pin2, 1);
    //Forward for RHS gearbox
    gpio_put(pin4, 0);
    gpio_put(pin5, 1);

    //sleep for duration specified
    sleep_ms(duration);

    //stop all
    gpio_put(pin1, 0);
    gpio_put(pin2, 0);
    //Forward for RHS gearbox
    gpio_put(pin4, 0);
    gpio_put(pin5, 0);




    //find the duration in seconds
    float timeS = duration/1000;
    printf("\nTime in seconds %.3f", timeS);

    //1% of max motor speed (based on 40 turns)
    float basePower = 3.775;
    //find the percentage at which the motor is running 
    float motorPercent = ((float)power/12500)* 100;
    printf("\nmotor power %.3f", motorPercent);
    //I.e, by the second, if 100%, distance = ~377.50mm / s , if 50% power ~188.75mm / s 
    float motorDistance = basePower * motorPercent;
    printf("\nMotor distance per second %.3f", motorDistance);
    //find the total distance as per the formula above, /1000 because in seconds
    float totalDistance = motorDistance * timeS;
    printf("\ndistance * time %.3f", totalDistance);


    //occasionally, last line doesn't print. Putting these random stuff prints it.
    printf("\n");
    printf("\n");
    printf("\n");

    // printf("Distance travelled:, %.3f, Time elapsed in seconds: %.3f, at motor power: %d" ,totalDistance, timeS, power);
    
}//PWM function

//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!



int main() {

    //initialization for USB cable (To print output)
    stdio_init_all();
    
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!

    //initialize pins 8, 10 and 9, 11
    gpio_init(pin8);
    gpio_init(groundPin9);
    gpio_init(pin11);
    gpio_init(groundPin12);
    //Enable the pins as "OUT" pins
    gpio_set_dir(pin8, GPIO_OUT);
    gpio_set_dir(groundPin9, GPIO_OUT);
    gpio_set_dir(pin11, GPIO_OUT);
    gpio_set_dir(groundPin12, GPIO_OUT);

    //power to pin 8 and 10
    gpio_put(pin8, 1);
    gpio_put(pin11, 1);
    //cut power to pin 9 and 12
    gpio_put(groundPin9, 0);
    gpio_put(groundPin12, 0);

    // //pin 13 used as the basis of this demonstration
    // gpio_set_irq_enabled_with_callback(13, GPIO_IRQ_EDGE_RISE, true, 
    // &distanceTravelled);    


//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!

    // Tell GPIO 0 they are allocated to the PWM
    gpio_set_function(0, GPIO_FUNC_PWM);
    // Tell GPIO and 6 they are allocated to the PWM
    gpio_set_function(6, GPIO_FUNC_PWM);

    //Set up ground pins for power output (logical 1/0, H/L)
    gpio_init(pin1);
    gpio_init(pin2);
    gpio_init(pin4);
    gpio_init(pin5);
    gpio_set_dir(pin1, GPIO_OUT);
    gpio_set_dir(pin2, GPIO_OUT);
    gpio_set_dir(pin4, GPIO_OUT);
    gpio_set_dir(pin5, GPIO_OUT);


    //NOTE: POV IS LOOKING AT L298N WITH BLACK HEATSINK FACING YOU, BLUE BITS FACING AWAY
    // 0 is the motor for the LHS
    // 6 is the motor for RHS.
    uint slice_num_motor1 = pwm_gpio_to_slice_num(0);
    uint slice_num_motor2 = pwm_gpio_to_slice_num(6);

    // Divide both clocks by 100, so 125Mhz / 100 = 1.25Mhz (1,250,000 Hz)
    pwm_set_clkdiv(slice_num_motor1, 100);
    pwm_set_clkdiv(slice_num_motor2, 100);

    //Set the value at which the controller "wraps around" or becomes 0
    //the original wrap value, 3, results in a very short, high frequency PWM.
    //After changing to 12,500, it changes to a longer, lower frequency PWM.
    //Corresponds to a period of 10ms (12,500/1,250,000 = 0.01s or 10ms)
    pwm_set_wrap(slice_num_motor1, 12500);
    pwm_set_wrap(slice_num_motor2, 12500);

    // Enable both PWM slices 
    pwm_set_enabled(slice_num_motor1, true);
    pwm_set_enabled(slice_num_motor2, true);
 

//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
sleep_ms(5000);
speedByPWM(fullPower, 4000);
// sleep_ms(1000);
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!
//FOR PWM SPEED CALCULATION ONLY!

    // while (1){
    // motorPower(fullPower);
    // moveForward();
    // //Note: DO NOT USE SLEEP in the final version. Use VtaskDelay as sleep blocks all
    // //other tasks from executing
    // sleep_ms(2000);

    // motorPower(halfPower);
    // // Motor 2 (RHS)
    // moveBackward();
    // sleep_ms(2000);
    
    // turnLeft();
    // sleep_ms(2000);

    // turnRight();
    // sleep_ms(2000);

    // pivotSteerLeft();
    // sleep_ms(4000);

    // pivotSteerRight();
    // sleep_ms(4000);

    // }//while loop
//DO NOT PUT ANYTHING HERE, DOES NOT RUN
}//main function
