//standard include statements
#include <stdio.h>

#include "pico/cyw43_arch.h"
#include "pico/stdlib.h"

#include "lwip/ip4_addr.h"

#include "FreeRTOS.h"
#include "task.h"
#include "ping.h"
#include "message_buffer.h"

#include "hardware/gpio.h"
//If there is an error here, just compile, it'll run like normal (Probably)
#include "hardware/adc.h"

#define mbaTASK_MESSAGE_BUFFER_SIZE       ( 60 )

#ifndef PING_ADDR
#define PING_ADDR "142.251.35.196"
#endif
#ifndef RUN_FREERTOS_ON_CORE
#define RUN_FREERTOS_ON_CORE 0
#endif

#define TEST_TASK_PRIORITY				( tskIDLE_PRIORITY + 1UL )

//for 10 point avg temp
static MessageBufferHandle_t xControlMessageBuffer;
//for simp avg temp
static MessageBufferHandle_t xControlMessageBuffer2;

//task4 buffer: moving Avgerage
static MessageBufferHandle_t xMovAvgMessageBuffer;
//task4 buffer SimpleAvg
static MessageBufferHandle_t xSimpAvgMessageBuffer;


//Func to read temp (For task 1)
float read_onboard_temperature() {
    
    /* 12-bit conversion, assume max value == ADC_VREF == 3.3 V */
    const float conversionFactor = 3.3f / (1 << 12);

    float adc = (float)adc_read() * conversionFactor;
    float tempC = 27.0f - (adc - 0.706f) / 0.001721f;

    return tempC;
}

/* A Task that obtains the data every 1000 ticks from the inbuilt temperature sensor (RP2040)
, prints it out and sends it to avg_task via message buffer */

//Task 1: Obtain the temperature and send it to tasks 2(10 moving avg) and 3 (Simple Avg)
void temp_task(__unused void *params) {
    float temperature = 0.0;

    //initialize ADC settings to detect temperature
    adc_init();
    adc_set_temp_sensor_enabled(true);
    adc_select_input(4);
    

    //run forever
    while(true) {
        //wait 1000ms (1s) before sending the data
        vTaskDelay(1000);
        //Read and initialize the onvoard temperaure 
        temperature = read_onboard_temperature();
        //send to 10 moving pt avg buffer
        xMessageBufferSend( 
            xControlMessageBuffer,    /* The message buffer to write to. */
            (void *) &temperature,    /* The source of the data to send. */
            sizeof( temperature ),    /* The length of the data to send. */
            0 );                      /* Do not block, should the buffer be full. */

        //send to simp avg buffer
        xMessageBufferSend( 
            xControlMessageBuffer2,    /* The message buffer to write to. */
            (void *) &temperature,    /* The source of the data to send. */
            sizeof( temperature ),    /* The length of the data to send. */
            0 );                      /* Do not block, should the buffer be full. */
    }
}

/* A Task that indefinitely waits for data from temp_task via message buffer. 
Once received, it will calculate the moving average and prints out the result. */

//Task 2: perform moving avg on 10 data points 
void avg_task(__unused void *params) {
    float fReceivedData;
    float sum = 0;
    float avgTemp = 0;
    size_t xReceivedBytes;
    
    //Chnaged from 4 to 10
    static float data[10] = {0};
    static int index = 0;
    static int count = 0;

    while(true) {
        //obtain data from MessageBufferReceive (For movinf average)
        xReceivedBytes = xMessageBufferReceive( 
            xControlMessageBuffer,        /* The message buffer to receive from. */
            (void *) &fReceivedData,      /* Location to store received data. */
            sizeof( fReceivedData ),      /* Maximum number of bytes to receive. */
            portMAX_DELAY );              /* Wait indefinitely */

            sum -= data[index];            // Subtract the oldest element from sum
            data[index] = fReceivedData;   // Assign the new element to the data
            sum += data[index];            // Add the new element to sum

            //Changed /4 to /10 to get average acorss 10 data points
            index = (index + 1) % 10;       // Update the index - make it circular
            
            //Changed from < 4 to <10
            if (count < 10) count++;        // Increment count till it reaches 10

            //Calculate the average temperature (10 data points)
            avgTemp = sum/count;

        //send message to moving average buffer
        xMessageBufferSend(
        xMovAvgMessageBuffer,   // The message buffer to write to (Task 4's buffer)
        (void*)&avgTemp,   // The source of the data to send
        sizeof(avgTemp),   // The length of the data to send
        0                    // Do not block if the buffer is full
        );
    }
}

//Task 3: Perform simple average  
void Simp_Task(__unused void *params) {
    //Essentially the divisor
    int count = 0;
    //Total temperature
    float tempSum = 0.0;
    // tempsum/count
    float simpAvgTemp = 0.0;

    //Receiving buffer use
    float fReceivedData;
    size_t xReceivedBytes;

    //Run forever
    while(true) {
        //Receive data from the buffer ConrolMessageBuffer2 (For this simp avg task)
        xReceivedBytes = xMessageBufferReceive( 
        xControlMessageBuffer2,        /* The message buffer to receive from. */
        (void *) &fReceivedData,      /* Location to store received data. */
        sizeof( fReceivedData ),      /* Maximum number of bytes to receive. */
        portMAX_DELAY );              /* Wait indefinitely */

        //Add the received data to the Temperature Sum
        tempSum += fReceivedData;
        //Increment the count
        count++;
        //Get simple average by dividing the tempSum / Count.
        simpAvgTemp = tempSum/count;

        //Send the simple Average into the buffer SimpAvgMessageBuffer
        xMessageBufferSend(
        xSimpAvgMessageBuffer,   // The message buffer to write to (Task 4's buffer)
        (void*)&simpAvgTemp,   // The source of the data to send
        sizeof(simpAvgTemp),   // The length of the data to send
        0                    // Do not block if the buffer is full
        );

    }//while loop
}//Task 3 overall

//task4 print task
void Task4_Function(void* pvParameters) {
    //Get values from buffers
    MessageBufferHandle_t xSimpAvgMessageBuffer = *((MessageBufferHandle_t*)pvParameters);
    MessageBufferHandle_t xMovAvgMessageBuffer = *((MessageBufferHandle_t*)pvParameters);

    float fReceivedData;
    size_t xReceivedBytes;

    //Run forever
    while (true) {
        //Receive data from the Simple average buffer
        xReceivedBytes = xMessageBufferReceive(
            xSimpAvgMessageBuffer,
            (void*)&fReceivedData,
            sizeof(fReceivedData),
            portMAX_DELAY);
        //Print out Simple Average
        printf("Simple Average: %0.2f\n", fReceivedData);

        //Receive data from the Moving Average buffer
        xReceivedBytes = xMessageBufferReceive(
            xMovAvgMessageBuffer,
            (void*)&fReceivedData,
            sizeof(fReceivedData),
            portMAX_DELAY);

        //Print out the data from the Moving average buffer
        printf("Moving Average: %0.2f\n", fReceivedData);

        //Wait 1s
        sleep_ms(1000);
    }
}

void vLaunch( void) {
    //Task 1: Take temp and send it to buffers xControlMessageBuffer and xControlMessageBuffer2
    TaskHandle_t temptask;
    xTaskCreate(temp_task, "TestTempThread", configMINIMAL_STACK_SIZE, NULL, 3, &temptask);
    //Task 2: Create 10 moving data point average
    TaskHandle_t avgtask;
    xTaskCreate(avg_task, "TestAvgThread", configMINIMAL_STACK_SIZE, NULL, 5, &avgtask);
    //Task 3: Simple average
    TaskHandle_t SimpTask;
    xTaskCreate(Simp_Task, "TestSimpThread", configMINIMAL_STACK_SIZE, NULL, 1, &SimpTask);
    //Task 4: Print stuff out
    TaskHandle_t Task4;
    xTaskCreate(Task4_Function, "Task4", configMINIMAL_STACK_SIZE, (void*)&xSimpAvgMessageBuffer, 6, &Task4);

    //Creation of individual buffers
    xControlMessageBuffer = xMessageBufferCreate(mbaTASK_MESSAGE_BUFFER_SIZE);
    xControlMessageBuffer2 = xMessageBufferCreate(mbaTASK_MESSAGE_BUFFER_SIZE);
    xSimpAvgMessageBuffer = xMessageBufferCreate(mbaTASK_MESSAGE_BUFFER_SIZE);
    xMovAvgMessageBuffer = xMessageBufferCreate(mbaTASK_MESSAGE_BUFFER_SIZE);

#if NO_SYS && configUSE_CORE_AFFINITY && configNUM_CORES > 1
    // we must bind the main task to one core (well at least while the init is called)
    // (note we only do this in NO_SYS mode, because cyw43_arch_freertos
    // takes care of it otherwise)
    vTaskCoreAffinitySet(task, 1);
#endif

    /* Start the tasks and timer running. */
    vTaskStartScheduler();
}

int main( void )
{
    stdio_init_all();

    /* Configure the hardware ready to run the demo. */
    const char *rtos_name;
#if ( portSUPPORT_SMP == 1 )
    rtos_name = "FreeRTOS SMP";
#else
    rtos_name = "FreeRTOS";
#endif

#if ( portSUPPORT_SMP == 1 ) && ( configNUM_CORES == 2 )
    printf("Starting %s on both cores:\n", rtos_name);
    vLaunch();
#elif ( RUN_FREERTOS_ON_CORE == 1 )
    printf("Starting %s on core 1:\n", rtos_name);
    multicore_launch_core1(vLaunch);
    while (true);
#else
    printf("Starting %s on core 0:\n", rtos_name);
    vLaunch();
#endif
    return 0;
}
